[INVALID_KEY_SET] predicate isLocalClassOrInterface(@classorinterface typeid, @localtypedeclstmt parent): The key set {typeid} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 1:
Tuple 1 in row 13: (1044,1050)
Tuple 2 in row 14: (1044,1075)
	Relevant element: Tuple 1: typeid=1044
		Full ID for 1044: @"class;L"
	Relevant element: Tuple 2: typeid=1044
		Full ID for 1044: @"class;L"
[INVALID_KEY_SET] predicate stmts(@stmt id, int kind, @stmtparent parent, int idx, @callable bodydecl): The key set {parent, idx} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 0:
Tuple 1 in row 223: (1047,0,1046,0,1046)
Tuple 2 in row 233: (1072,0,1046,0,1046)
	Relevant element: Tuple 1: parent=1046
		Full ID for 1046: @"callable;(1044).<init>()(17)". The ID may expand to @"callable;{@"class;L"}.<init>(){@"type;void"}"
	Relevant element: Tuple 2: parent=1046
		Full ID for 1046: @"callable;(1044).<init>()(17)". The ID may expand to @"callable;{@"class;L"}.<init>(){@"type;void"}"
	Relevant element: Tuple 1: bodydecl=1046
		Full ID for 1046: @"callable;(1044).<init>()(17)". The ID may expand to @"callable;{@"class;L"}.<init>(){@"type;void"}"
	Relevant element: Tuple 2: bodydecl=1046
		Full ID for 1046: @"callable;(1044).<init>()(17)". The ID may expand to @"callable;{@"class;L"}.<init>(){@"type;void"}"
