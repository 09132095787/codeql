/**
 * @id java/summary/generated-vs-manual-coverage
 * @name Metrics of generated versus manual MaD coverage
 * @description Expose metrics for the number of API endpoints covered by generated versus manual MaD models.
 * @kind table
 * @tags summary
 */

//import java // not needed I guess
import semmle.code.java.dataflow.FlowSummary // for SummarizedCallable
import utils.modelgenerator.internal.CaptureModels // for DataFlowTargetApi
import semmle.code.java.dataflow.internal.FlowSummaryImpl as FlowSummaryImpl // for NegativeSummarizedCallable

// ! improve QLDoc?
/**
 * A callable for a given library that is modeled by MaD.
 * Specifically, this callable is the intersection of
 * DataFlowTargetApis and SummarizedCallables.
 */
class MadModeledCallable extends SummarizedCallableBase {
  // ! better name for this class?
  MadModeledCallable() {
    this instanceof SummarizedCallable and
    exists(DataFlowTargetApi dataFlowTargApi | this.asCallable() = dataFlowTargApi)
  }
}

// ! move to other file
/**
 * Returns the number of APIs with MaD models
 * for a given package and provenance.
 */
float getNumMadModels(string package, string provenance) {
  exists(MadModeledCallable mc |
    package = mc.asCallable().getDeclaringType().getPackage().toString() and
    provenance in ["generated", "manual", "both"]
  |
    result =
      count(MadModeledCallable c |
        package = c.asCallable().getDeclaringType().getPackage().toString() and
        (
          c.(SummarizedCallable).isAutoGenerated() and // generated and NOT manual = "auto-only"
          provenance = "generated"
          or
          c.(SummarizedCallable).isManuallyGenerated() and // manual and NOT generated = "manual-only"
          provenance = "manual"
          or
          c.(SummarizedCallable).isBothAutoAndManuallyGenerated() and // BOTH generated and manual = "both"
          provenance = "both"
        )
      )
  )
}

// ! move to other file
/**
 * Returns the number of APIs without SummarizedCallables
 * (MaD models) for a given package.
 */
float getNumApisWithoutMadModel(string package) {
  exists(DataFlowTargetApi dataFlowTargApi |
    package = dataFlowTargApi.getDeclaringType().getPackage().toString()
  |
    result =
      count(DataFlowTargetApi d |
        package = d.getDeclaringType().getPackage().toString() and
        not exists(MadModeledCallable sc | d = sc.asCallable())
      )
  )
}

/**
 * Returns the total number of APIs for a given package.
 */
float getNumApis(string package) {
  exists(DataFlowTargetApi dataFlowTargApi |
    package = dataFlowTargApi.getDeclaringType().getPackage().toString()
  |
    result = count(DataFlowTargetApi d | package = d.getDeclaringType().getPackage().toString())
  )
}

from
  string package, float generatedOnly, float both, float manualOnly, float non, float all,
  float generatedCoverage, float manualCoverage
where
  generatedOnly = getNumMadModels(package, "generated") and
  manualOnly = getNumMadModels(package, "manual") and
  both = getNumMadModels(package, "both") and
  // non = getNumApisWithoutMadModel(package) and
  // all = generatedOnly + both + manualOnly + non and
  all = getNumApis(package) and
  non = all - (generatedOnly + both + manualOnly) and
  generatedCoverage = (both / (both + manualOnly)) and // Proportion of manual models covered by generated ones
  manualCoverage = (both / (both + generatedOnly)) // Proportion of generated models covered by manual ones
select package, generatedOnly, both, manualOnly, non, all, generatedCoverage, manualCoverage
  order by package
// * "all" and "none" tests
// from string package, float num
// where num = getNumApis(package) // allY2 = DFTAs
// // where num = getNumModeledApis(package) // allY1 = api that has either a positive or negative model
// // where num = getNumApisWithoutMadModel(package) // noneY2 = DFTAs \ SCs
// select package, num order by package
