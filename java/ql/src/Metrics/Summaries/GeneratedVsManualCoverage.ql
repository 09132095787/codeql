/**
 * @id java/summary/generated-vs-manual-coverage
 * @name Metrics of generated versus manual MaD coverage
 * @description Expose metrics for the number of API endpoints covered by generated versus manual MaD models.
 * @kind table
 * @tags summary
 */

//import java // not needed I guess
import semmle.code.java.dataflow.FlowSummary // for SummarizedCallable
import utils.modelgenerator.internal.CaptureModels // for DataFlowTargetApi
import semmle.code.java.dataflow.internal.FlowSummaryImpl as FlowSummaryImpl // for NegativeSummarizedCallable

// ! improve QLDoc?
/**
 * A callable for a given library that is modeled by MaD.
 * Specifically, this callable is the intersection of
 * DataFlowTargetApis and SummarizedCallables.
 */
class MadModeledCallable extends SummarizedCallableBase {
  // ! better name for this class?
  MadModeledCallable() {
    (
      this instanceof SummarizedCallable or
      this instanceof FlowSummaryImpl::Public::NegativeSummarizedCallable
    ) and
    exists(DataFlowTargetApi dataFlowTargApi | this.asCallable() = dataFlowTargApi)
  }
}

// ! move to other file
// ! separate this into pos and neg predicates instead of using `posOrNeg` flag?
/**
 * Returns the number of APIs with MaD models
 * for a given package and provenance.
 */
float getNumMadModels(string package, string provenance, string posOrNeg) {
  exists(MadModeledCallable mc |
    package = mc.asCallable().getDeclaringType().getPackage().toString() and
    provenance in ["generated", "manual", "both"] and
    posOrNeg in ["positive", "negative"]
  |
    if posOrNeg = "positive"
    then
      result =
        count(MadModeledCallable c |
          package = c.asCallable().getDeclaringType().getPackage().toString() and
          (
            c.(SummarizedCallable).isAutoGenerated() and // generated and NOT manual = "auto-only"
            provenance = "generated"
            or
            c.(SummarizedCallable).isManuallyGenerated() and // manual and NOT generated = "manual-only"
            provenance = "manual"
            or
            c.(SummarizedCallable).isBothAutoAndManuallyGenerated() and // BOTH generated and manual = "both"
            provenance = "both"
          )
        )
    else
      result =
        count(MadModeledCallable c |
          package = c.asCallable().getDeclaringType().getPackage().toString() and
          (
            c.(FlowSummaryImpl::Public::NegativeSummarizedCallable).isAutoGenerated() and // generated and NOT manual = "auto-only"
            provenance = "generated"
            or
            c.(FlowSummaryImpl::Public::NegativeSummarizedCallable).isManuallyGenerated() and // manual and NOT generated = "manual-only"
            provenance = "manual"
            or
            c.(FlowSummaryImpl::Public::NegativeSummarizedCallable).isBothAutoAndManuallyGenerated() and // BOTH generated and manual = "both"
            provenance = "both"
          )
        )
  )
}

// ! move to other file
/**
 * Returns the number of APIs without MaD
 * models for a given package.
 */
float getNumApisWithoutMadModel(string package) {
  exists(DataFlowTargetApi dataFlowTargApi |
    package = dataFlowTargApi.getDeclaringType().getPackage().toString()
  |
    result =
      count(DataFlowTargetApi d |
        package = d.getDeclaringType().getPackage().toString() and
        not exists(SummarizedCallable sc | d = sc.asCallable()) and
        not exists(FlowSummaryImpl::Public::NegativeSummarizedCallable nc | d = nc.asCallable())
      )
  )
}

// ! Note: adjust metric formulas as needed after more discussion with Yorck
/*
 * metric1:
 * Proportion of manual models covered by automation: “both” / (“both” + “manual-only”)
 * Auto-generated vs all positive manual (percentage of manual models covered by auto-generation)
 */

/*
 * metric2:
 * Coverage relative to total number of APIs: (“auto-only” + “both” + “manual-only”) / “all”
 * Auto-generated vs specific pos+neg subset (top-N manual, random)
 */

from
  string package, float generatedPos, float manualPos, float bothPos, float generatedNeg,
  float manualNeg, float bothNeg, float notModeled, float all, float metric1, float metric2
where
  generatedPos = getNumMadModels(package, "generated", "positive") and
  manualPos = getNumMadModels(package, "manual", "positive") and
  bothPos = getNumMadModels(package, "both", "positive") and
  generatedNeg = getNumMadModels(package, "generated", "negative") and
  manualNeg = getNumMadModels(package, "manual", "negative") and
  bothNeg = getNumMadModels(package, "both", "negative") and
  notModeled = getNumApisWithoutMadModel(package) and
  all = generatedPos + manualPos + bothPos + generatedNeg + manualNeg + bothNeg + notModeled and
  metric1 = (bothPos / (bothPos + manualPos)) and // ! I believe this metric was intended to be only on the positive ones?
  metric2 = (generatedPos + generatedNeg + bothPos + bothNeg + manualPos + manualNeg) / all
select package, generatedPos, manualPos, bothPos, generatedNeg, manualNeg, bothNeg, notModeled, all,
  metric1, metric2 order by package
