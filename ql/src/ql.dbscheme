// CodeQL database schema for QL
// Automatically generated from the tree-sitter grammar; do not edit

@location = @location_default

locations_default(
  unique int id: @location_default,
  int file: @file ref,
  int start_line: int ref,
  int start_column: int ref,
  int end_line: int ref,
  int end_column: int ref
);

@sourceline = @file

numlines(
  int element_id: @sourceline ref,
  int num_lines: int ref,
  int num_code: int ref,
  int num_comment: int ref
);

files(
  unique int id: @file,
  string name: string ref,
  string simple: string ref,
  string ext: string ref,
  int fromSource: int ref
);

folders(
  unique int id: @folder,
  string name: string ref,
  string simple: string ref
);

@container = @file | @folder

containerparent(
  int parent: @container ref,
  unique int child: @container ref
);

sourceLocationPrefix(
  string prefix: string ref
);

@add_expr_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@add_expr_right_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

add_expr_def(
  unique int id: @add_expr,
  int left: @add_expr_left_type ref,
  int right: @add_expr_right_type ref,
  int child: @token_addop ref,
  int loc: @location ref
);

@aggregate_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_aggregate_body | @expr_annotation | @full_aggregate_body | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @token_agg_id | @unary_expr | @variable

#keyset[aggregate, index]
aggregate_child(
  int aggregate: @aggregate ref,
  int index: int ref,
  unique int child: @aggregate_child_type ref
);

aggregate_def(
  unique int id: @aggregate,
  int loc: @location ref
);

@annotArg_child_type = @token_result | @token_simple_id | @token_this

annot_arg_def(
  unique int id: @annot_arg,
  int child: @annotArg_child_type ref,
  int loc: @location ref
);

@annotation_args_type = @annot_arg | @reserved_word

#keyset[annotation, index]
annotation_args(
  int annotation: @annotation ref,
  int index: int ref,
  unique int args: @annotation_args_type ref
);

annotation_def(
  unique int id: @annotation,
  int name: @token_annot_name ref,
  int loc: @location ref
);

arityless_predicate_expr_child(
  unique int arityless_predicate_expr: @arityless_predicate_expr ref,
  unique int child: @module_expr ref
);

arityless_predicate_expr_def(
  unique int id: @arityless_predicate_expr,
  int name: @token_literal_id ref,
  int loc: @location ref
);

@asExpr_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @var_name | @variable

#keyset[as_expr, index]
as_expr_child(
  int as_expr: @as_expr ref,
  int index: int ref,
  unique int child: @asExpr_child_type ref
);

as_expr_def(
  unique int id: @as_expr,
  int loc: @location ref
);

#keyset[as_exprs, index]
as_exprs_child(
  int as_exprs: @as_exprs ref,
  int index: int ref,
  unique int child: @as_expr ref
);

as_exprs_def(
  unique int id: @as_exprs,
  int loc: @location ref
);

@body_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

body_def(
  unique int id: @body,
  int child: @body_child_type ref,
  int loc: @location ref
);

@bool_child_type = @token_false | @token_true

bool_def(
  unique int id: @bool,
  int child: @bool_child_type ref,
  int loc: @location ref
);

@call_body_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @token_underscore | @unary_expr | @variable

#keyset[call_body, index]
call_body_child(
  int call_body: @call_body ref,
  int index: int ref,
  unique int child: @call_body_child_type ref
);

call_body_def(
  unique int id: @call_body,
  int loc: @location ref
);

@call_or_unqual_agg_expr_child_type = @arityless_predicate_expr | @call_body | @token_closure | @unqual_agg_body

#keyset[call_or_unqual_agg_expr, index]
call_or_unqual_agg_expr_child(
  int call_or_unqual_agg_expr: @call_or_unqual_agg_expr ref,
  int index: int ref,
  unique int child: @call_or_unqual_agg_expr_child_type ref
);

call_or_unqual_agg_expr_def(
  unique int id: @call_or_unqual_agg_expr,
  int loc: @location ref
);

@charpred_body_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

charpred_def(
  unique int id: @charpred,
  int body: @charpred_body_type ref,
  int child: @token_class_name ref,
  int loc: @location ref
);

@classMember_child_type = @annotation | @charpred | @field | @member_predicate | @token_qldoc

#keyset[class_member, index]
class_member_child(
  int class_member: @class_member ref,
  int index: int ref,
  unique int child: @classMember_child_type ref
);

class_member_def(
  unique int id: @class_member,
  int loc: @location ref
);

@classlessPredicate_returnType_type = @token_predicate | @type_expr

@classlessPredicate_child_type = @body | @higher_order_term | @predicate_alias_body | @token_empty | @var_decl

#keyset[classless_predicate, index]
classless_predicate_child(
  int classless_predicate: @classless_predicate ref,
  int index: int ref,
  unique int child: @classlessPredicate_child_type ref
);

classless_predicate_def(
  unique int id: @classless_predicate,
  int name: @token_predicate_name ref,
  int return_type: @classlessPredicate_returnType_type ref,
  int loc: @location ref
);

@comp_term_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@comp_term_right_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

comp_term_def(
  unique int id: @comp_term,
  int left: @comp_term_left_type ref,
  int right: @comp_term_right_type ref,
  int child: @token_compop ref,
  int loc: @location ref
);

@conjunction_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@conjunction_right_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

conjunction_def(
  unique int id: @conjunction,
  int left: @conjunction_left_type ref,
  int right: @conjunction_right_type ref,
  int loc: @location ref
);

@dataclass_child_type = @class_member | @type_alias_body | @type_expr | @type_union_body

#keyset[dataclass, index]
dataclass_child(
  int dataclass: @dataclass ref,
  int index: int ref,
  unique int child: @dataclass_child_type ref
);

dataclass_def(
  unique int id: @dataclass,
  int name: @token_class_name ref,
  int loc: @location ref
);

datatype_def(
  unique int id: @datatype,
  int name: @token_class_name ref,
  int child: @datatype_branches ref,
  int loc: @location ref
);

@datatypeBranch_child_type = @annotation | @body | @token_qldoc | @var_decl

#keyset[datatype_branch, index]
datatype_branch_child(
  int datatype_branch: @datatype_branch ref,
  int index: int ref,
  unique int child: @datatypeBranch_child_type ref
);

datatype_branch_def(
  unique int id: @datatype_branch,
  int name: @token_class_name ref,
  int loc: @location ref
);

#keyset[datatype_branches, index]
datatype_branches_child(
  int datatype_branches: @datatype_branches ref,
  int index: int ref,
  unique int child: @datatype_branch ref
);

datatype_branches_def(
  unique int id: @datatype_branches,
  int loc: @location ref
);

@disjunction_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@disjunction_right_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

disjunction_def(
  unique int id: @disjunction,
  int left: @disjunction_left_type ref,
  int right: @disjunction_right_type ref,
  int loc: @location ref
);

expr_aggregate_body_order_bys(
  unique int expr_aggregate_body: @expr_aggregate_body ref,
  unique int orderBys: @order_bys ref
);

expr_aggregate_body_def(
  unique int id: @expr_aggregate_body,
  int as_exprs: @as_exprs ref,
  int loc: @location ref
);

@expr_annotation_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

expr_annotation_def(
  unique int id: @expr_annotation,
  int annot_arg: @token_annot_name ref,
  int name: @token_annot_name ref,
  int child: @expr_annotation_child_type ref,
  int loc: @location ref
);

field_def(
  unique int id: @field,
  int child: @var_decl ref,
  int loc: @location ref
);

full_aggregate_body_as_exprs(
  unique int full_aggregate_body: @full_aggregate_body ref,
  unique int asExprs: @as_exprs ref
);

@full_aggregate_body_guard_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

full_aggregate_body_guard(
  unique int full_aggregate_body: @full_aggregate_body ref,
  unique int guard: @full_aggregate_body_guard_type ref
);

full_aggregate_body_order_bys(
  unique int full_aggregate_body: @full_aggregate_body ref,
  unique int orderBys: @order_bys ref
);

#keyset[full_aggregate_body, index]
full_aggregate_body_child(
  int full_aggregate_body: @full_aggregate_body ref,
  int index: int ref,
  unique int child: @var_decl ref
);

full_aggregate_body_def(
  unique int id: @full_aggregate_body,
  int loc: @location ref
);

@higherOrderTerm_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @predicate_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @token_underscore | @unary_expr | @variable

#keyset[higher_order_term, index]
higher_order_term_child(
  int higher_order_term: @higher_order_term ref,
  int index: int ref,
  unique int child: @higherOrderTerm_child_type ref
);

higher_order_term_def(
  unique int id: @higher_order_term,
  int name: @token_literal_id ref,
  int loc: @location ref
);

@if_term_cond_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@if_term_first_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@if_term_second_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

if_term_def(
  unique int id: @if_term,
  int cond: @if_term_cond_type ref,
  int first: @if_term_first_type ref,
  int second: @if_term_second_type ref,
  int loc: @location ref
);

@implication_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@implication_right_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

implication_def(
  unique int id: @implication,
  int left: @implication_left_type ref,
  int right: @implication_right_type ref,
  int loc: @location ref
);

@importDirective_child_type = @import_module_expr | @module_name

#keyset[import_directive, index]
import_directive_child(
  int import_directive: @import_directive ref,
  int index: int ref,
  unique int child: @importDirective_child_type ref
);

import_directive_def(
  unique int id: @import_directive,
  int loc: @location ref
);

#keyset[import_module_expr, index]
import_module_expr_name(
  int import_module_expr: @import_module_expr ref,
  int index: int ref,
  unique int name: @token_simple_id ref
);

import_module_expr_def(
  unique int id: @import_module_expr,
  int child: @qual_module_expr ref,
  int loc: @location ref
);

@in_expr_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@in_expr_right_type = @aggregate | @call_or_unqual_agg_expr | @expr_annotation | @literal | @par_expr | @qualified_expr | @range | @set_literal | @super_ref | @variable

in_expr_def(
  unique int id: @in_expr,
  int left: @in_expr_left_type ref,
  int right: @in_expr_right_type ref,
  int loc: @location ref
);

@instance_of_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @type_expr | @unary_expr | @variable

#keyset[instance_of, index]
instance_of_child(
  int instance_of: @instance_of ref,
  int index: int ref,
  unique int child: @instance_of_child_type ref
);

instance_of_def(
  unique int id: @instance_of,
  int loc: @location ref
);

@literal_child_type = @bool | @token_float | @token_integer | @token_string

literal_def(
  unique int id: @literal,
  int child: @literal_child_type ref,
  int loc: @location ref
);

@memberPredicate_returnType_type = @token_predicate | @type_expr

@memberPredicate_child_type = @body | @higher_order_term | @token_empty | @var_decl

#keyset[member_predicate, index]
member_predicate_child(
  int member_predicate: @member_predicate ref,
  int index: int ref,
  unique int child: @memberPredicate_child_type ref
);

member_predicate_def(
  unique int id: @member_predicate,
  int name: @token_predicate_name ref,
  int return_type: @memberPredicate_returnType_type ref,
  int loc: @location ref
);

@module_child_type = @module_alias_body | @module_member

#keyset[module, index]
module_child(
  int module: @module ref,
  int index: int ref,
  unique int child: @module_child_type ref
);

module_def(
  unique int id: @module,
  int name: @module_name ref,
  int loc: @location ref
);

module_alias_body_def(
  unique int id: @module_alias_body,
  int child: @module_expr ref,
  int loc: @location ref
);

module_expr_name(
  unique int module_expr: @module_expr ref,
  unique int name: @token_simple_id ref
);

@moduleExpr_child_type = @module_expr | @token_simple_id

module_expr_def(
  unique int id: @module_expr,
  int child: @moduleExpr_child_type ref,
  int loc: @location ref
);

@moduleMember_child_type = @annotation | @classless_predicate | @dataclass | @datatype | @import_directive | @module | @select | @token_qldoc

#keyset[module_member, index]
module_member_child(
  int module_member: @module_member ref,
  int index: int ref,
  unique int child: @moduleMember_child_type ref
);

module_member_def(
  unique int id: @module_member,
  int loc: @location ref
);

module_name_def(
  unique int id: @module_name,
  int child: @token_simple_id ref,
  int loc: @location ref
);

@mul_expr_left_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@mul_expr_right_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

mul_expr_def(
  unique int id: @mul_expr,
  int left: @mul_expr_left_type ref,
  int right: @mul_expr_right_type ref,
  int child: @token_mulop ref,
  int loc: @location ref
);

@negation_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

negation_def(
  unique int id: @negation,
  int child: @negation_child_type ref,
  int loc: @location ref
);

@orderBy_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @token_direction | @unary_expr | @variable

#keyset[order_by, index]
order_by_child(
  int order_by: @order_by ref,
  int index: int ref,
  unique int child: @orderBy_child_type ref
);

order_by_def(
  unique int id: @order_by,
  int loc: @location ref
);

#keyset[order_bys, index]
order_bys_child(
  int order_bys: @order_bys ref,
  int index: int ref,
  unique int child: @order_by ref
);

order_bys_def(
  unique int id: @order_bys,
  int loc: @location ref
);

@par_expr_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

par_expr_def(
  unique int id: @par_expr,
  int child: @par_expr_child_type ref,
  int loc: @location ref
);

predicate_alias_body_def(
  unique int id: @predicate_alias_body,
  int child: @predicate_expr ref,
  int loc: @location ref
);

@predicateExpr_child_type = @arityless_predicate_expr | @token_integer

#keyset[predicate_expr, index]
predicate_expr_child(
  int predicate_expr: @predicate_expr ref,
  int index: int ref,
  unique int child: @predicateExpr_child_type ref
);

predicate_expr_def(
  unique int id: @predicate_expr,
  int loc: @location ref
);

@prefix_cast_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @type_expr | @unary_expr | @variable

#keyset[prefix_cast, index]
prefix_cast_child(
  int prefix_cast: @prefix_cast ref,
  int index: int ref,
  unique int child: @prefix_cast_child_type ref
);

prefix_cast_def(
  unique int id: @prefix_cast,
  int loc: @location ref
);

#keyset[ql, index]
ql_child(
  int ql: @ql ref,
  int index: int ref,
  unique int child: @module_member ref
);

ql_def(
  unique int id: @ql,
  int loc: @location ref
);

#keyset[qual_module_expr, index]
qual_module_expr_name(
  int qual_module_expr: @qual_module_expr ref,
  int index: int ref,
  unique int name: @token_simple_id ref
);

qual_module_expr_def(
  unique int id: @qual_module_expr,
  int loc: @location ref
);

qualified_rhs_name(
  unique int qualified_rhs: @qualified_rhs ref,
  unique int name: @token_predicate_name ref
);

@qualifiedRhs_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @token_closure | @token_underscore | @type_expr | @unary_expr | @variable

#keyset[qualified_rhs, index]
qualified_rhs_child(
  int qualified_rhs: @qualified_rhs ref,
  int index: int ref,
  unique int child: @qualifiedRhs_child_type ref
);

qualified_rhs_def(
  unique int id: @qualified_rhs,
  int loc: @location ref
);

@qualified_expr_child_type = @aggregate | @call_or_unqual_agg_expr | @expr_annotation | @literal | @par_expr | @qualified_expr | @qualified_rhs | @range | @set_literal | @super_ref | @variable

#keyset[qualified_expr, index]
qualified_expr_child(
  int qualified_expr: @qualified_expr ref,
  int index: int ref,
  unique int child: @qualified_expr_child_type ref
);

qualified_expr_def(
  unique int id: @qualified_expr,
  int loc: @location ref
);

@quantified_expr_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

quantified_expr(
  unique int quantified: @quantified ref,
  unique int expr: @quantified_expr_type ref
);

@quantified_formula_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

quantified_formula(
  unique int quantified: @quantified ref,
  unique int formula: @quantified_formula_type ref
);

@quantified_range_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

quantified_range(
  unique int quantified: @quantified ref,
  unique int range: @quantified_range_type ref
);

@quantified_child_type = @token_quantifier | @var_decl

#keyset[quantified, index]
quantified_child(
  int quantified: @quantified ref,
  int index: int ref,
  unique int child: @quantified_child_type ref
);

quantified_def(
  unique int id: @quantified,
  int loc: @location ref
);

@range_lower_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

@range_upper_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

range_def(
  unique int id: @range,
  int lower: @range_lower_type ref,
  int upper: @range_upper_type ref,
  int loc: @location ref
);

@select_child_type = @add_expr | @aggregate | @as_exprs | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @order_bys | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @var_decl | @variable

#keyset[select, index]
select_child(
  int select: @select ref,
  int index: int ref,
  unique int child: @select_child_type ref
);

select_def(
  unique int id: @select,
  int loc: @location ref
);

@set_literal_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

#keyset[set_literal, index]
set_literal_child(
  int set_literal: @set_literal ref,
  int index: int ref,
  unique int child: @set_literal_child_type ref
);

set_literal_def(
  unique int id: @set_literal,
  int loc: @location ref
);

special_call_def(
  unique int id: @special_call,
  int child: @token_special_id ref,
  int loc: @location ref
);

@super_ref_child_type = @token_super | @type_expr

#keyset[super_ref, index]
super_ref_child(
  int super_ref: @super_ref ref,
  int index: int ref,
  unique int child: @super_ref_child_type ref
);

super_ref_def(
  unique int id: @super_ref,
  int loc: @location ref
);

type_alias_body_def(
  unique int id: @type_alias_body,
  int child: @type_expr ref,
  int loc: @location ref
);

type_expr_name(
  unique int type_expr: @type_expr ref,
  unique int name: @token_class_name ref
);

@typeExpr_child_type = @module_expr | @token_dbtype | @token_primitive_type

type_expr_child(
  unique int type_expr: @type_expr ref,
  unique int child: @typeExpr_child_type ref
);

type_expr_def(
  unique int id: @type_expr,
  int loc: @location ref
);

#keyset[type_union_body, index]
type_union_body_child(
  int type_union_body: @type_union_body ref,
  int index: int ref,
  unique int child: @type_expr ref
);

type_union_body_def(
  unique int id: @type_union_body,
  int loc: @location ref
);

@unary_expr_child_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @token_unop | @unary_expr | @variable

#keyset[unary_expr, index]
unary_expr_child(
  int unary_expr: @unary_expr ref,
  int index: int ref,
  unique int child: @unary_expr_child_type ref
);

unary_expr_def(
  unique int id: @unary_expr,
  int loc: @location ref
);

@unqual_agg_body_asExprs_type = @as_exprs | @reserved_word

#keyset[unqual_agg_body, index]
unqual_agg_body_as_exprs(
  int unqual_agg_body: @unqual_agg_body ref,
  int index: int ref,
  unique int asExprs: @unqual_agg_body_asExprs_type ref
);

@unqual_agg_body_guard_type = @add_expr | @aggregate | @call_or_unqual_agg_expr | @comp_term | @conjunction | @disjunction | @expr_annotation | @if_term | @implication | @in_expr | @instance_of | @literal | @mul_expr | @negation | @par_expr | @prefix_cast | @qualified_expr | @quantified | @range | @set_literal | @special_call | @super_ref | @unary_expr | @variable

unqual_agg_body_guard(
  unique int unqual_agg_body: @unqual_agg_body ref,
  unique int guard: @unqual_agg_body_guard_type ref
);

#keyset[unqual_agg_body, index]
unqual_agg_body_child(
  int unqual_agg_body: @unqual_agg_body ref,
  int index: int ref,
  unique int child: @var_decl ref
);

unqual_agg_body_def(
  unique int id: @unqual_agg_body,
  int loc: @location ref
);

@varDecl_child_type = @type_expr | @var_name

#keyset[var_decl, index]
var_decl_child(
  int var_decl: @var_decl ref,
  int index: int ref,
  unique int child: @varDecl_child_type ref
);

var_decl_def(
  unique int id: @var_decl,
  int loc: @location ref
);

var_name_def(
  unique int id: @var_name,
  int child: @token_simple_id ref,
  int loc: @location ref
);

@variable_child_type = @token_result | @token_this | @var_name

variable_def(
  unique int id: @variable,
  int child: @variable_child_type ref,
  int loc: @location ref
);

tokeninfo(
  unique int id: @token,
  int kind: int ref,
  int file: @file ref,
  int idx: int ref,
  string value: string ref,
  int loc: @location ref
);

case @token.kind of
  0 = @reserved_word
| 1 = @token_addop
| 2 = @token_agg_id
| 3 = @token_annot_name
| 4 = @token_block_comment
| 5 = @token_class_name
| 6 = @token_closure
| 7 = @token_compop
| 8 = @token_dbtype
| 9 = @token_direction
| 10 = @token_empty
| 11 = @token_false
| 12 = @token_float
| 13 = @token_integer
| 14 = @token_line_comment
| 15 = @token_literal_id
| 16 = @token_mulop
| 17 = @token_predicate
| 18 = @token_predicate_name
| 19 = @token_primitive_type
| 20 = @token_qldoc
| 21 = @token_quantifier
| 22 = @token_result
| 23 = @token_simple_id
| 24 = @token_special_id
| 25 = @token_string
| 26 = @token_super
| 27 = @token_this
| 28 = @token_true
| 29 = @token_underscore
| 30 = @token_unop
;


diagnostics(
  unique int id: @diagnostic,
  int severity: int ref,
  string error_tag: string ref,
  string error_message: string ref,
  string full_error_message: string ref,
  int location: @location_default ref
);

case @diagnostic.severity of
  10 = @diagnostic_debug
| 20 = @diagnostic_info
| 30 = @diagnostic_warning
| 40 = @diagnostic_error
;


@ast_node = @add_expr | @aggregate | @annot_arg | @annotation | @arityless_predicate_expr | @as_expr | @as_exprs | @body | @bool | @call_body | @call_or_unqual_agg_expr | @charpred | @class_member | @classless_predicate | @comp_term | @conjunction | @dataclass | @datatype | @datatype_branch | @datatype_branches | @disjunction | @expr_aggregate_body | @expr_annotation | @field | @full_aggregate_body | @higher_order_term | @if_term | @implication | @import_directive | @import_module_expr | @in_expr | @instance_of | @literal | @member_predicate | @module | @module_alias_body | @module_expr | @module_member | @module_name | @mul_expr | @negation | @order_by | @order_bys | @par_expr | @predicate_alias_body | @predicate_expr | @prefix_cast | @ql | @qual_module_expr | @qualified_expr | @qualified_rhs | @quantified | @range | @select | @set_literal | @special_call | @super_ref | @token | @type_alias_body | @type_expr | @type_union_body | @unary_expr | @unqual_agg_body | @var_decl | @var_name | @variable

@ast_node_parent = @ast_node | @file

#keyset[parent, parent_index]
ast_node_parent(
  int child: @ast_node ref,
  int parent: @ast_node_parent ref,
  int parent_index: int ref
);

