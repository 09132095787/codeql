// generated by {{generator}}

{{#imports}}
import {{.}}
{{/imports}}

// we are defining this class mainly to leverage existing generation machinery
// when we generate getters in classes we use the db predicate with `this`. In order to reuse that we need a class here
// as well
private class ElementWithChildAccessor extends Element {
    // why does this look more complicated than it should?
    // * the none()  simplifies generation, as we can append `or ...` without a special case for the first item
    // * the `exists` and the `x` variables are there to reuse the same generation done in classes (where the variables
    //   are used to hide nodes via resolution)
    Element getAnImmediateChild() {
      none()
      {{#classes}}
      {{#properties}}
      {{#is_child}}
      or
      exists({{type}} {{local_var}}{{#is_repeated}}, int index{{/is_repeated}} | {{tablename}}({{#tableparams}}{{^first}}, {{/first}}{{param}}{{/tableparams}}) and result = {{local_var}})
      {{/is_child}}
      {{/properties}}
      {{/classes}}
   }
}

/**
 * Gets any of the "immediate" children of `e`. "Immediate" means not taking into account node resolution: for example
 * if the AST child is the first of a series of conversions that would normally be hidden away, this will select the
 * next conversion down the hidden AST tree instead of the corresponding fully uncoverted node at the bottom.
 * This predicate is mainly intended to be used to test uniqueness of parents.
 */
cached
Element getAnImmediateChild(Element e) {
   result = e.(ElementWithChildAccessor).getAnImmediateChild()
}

/**
 * Gets the "immediate" parent of `e`. "Immediate" means not taking into account node resolution: for example
 * if `e` has conversions, `getImmediateParent(e)` will give the bottom conversion in the hidden AST.
 */
 Element getImmediateParent(Element e) {
   result = unique(Element x | e = getAnImmediateChild(x) | x)
}
