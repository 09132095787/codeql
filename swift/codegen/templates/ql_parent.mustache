// generated by {{generator}}

import codeql.swift.elements

private module Impl {
{{#classes}}
int getMaximumChildrenIndex{{name}}({{name}} e) {
  {{#root}}e = e and{{/root}}
  result = 0
    {{#bases}}
    + getMaximumChildrenIndex{{.}}(e)
    {{/bases}}
    {{#properties}}
    {{#is_child}}
    + 1{{#is_repeated}}+ max(int i | exists(e.getImmediate{{singular}}(i)) | i){{/is_repeated}}
    {{/is_child}}
    {{/properties}}
}

{{/classes}}
/**
 * Gets any of the "immediate" children of `e`. "Immediate" means not taking into account node resolution: for example
 * if the AST child is the first of a series of conversions that would normally be hidden away, this will select the
 * next conversion down the hidden AST tree instead of the corresponding fully uncoverted node at the bottom.
 * Outside this module this file is mainly intended to be used to test uniqueness of parents.
 */
cached
Element getImmediateChild(Element e, int index, string partialAccessor) {
  // why does this look more complicated than it should?
  // * none() simplifies generation, as we can append `or ...` without a special case for the first item
  none()
  {{#classes}}
      {{#has_children}}
      or
      exists(int n{{#properties}}{{#is_child}}, int n{{singular}}{{/is_child}}{{/properties}} |
        n = 0{{#bases}} + getMaximumChildrenIndex{{.}}(e){{/bases}}
        {{#properties}}
        {{#is_child}}
        and n{{singular}} = n{{prev_child}} + 1{{#is_repeated}} + max(int i | i = 0 or exists(e.({{name}}).getImmediate{{singular}}(i)) | i){{/is_repeated}}
        {{/is_child}}
        {{/properties}}
        and (
            none()
            {{#properties}}
            {{#is_child}}
            or
            {{#is_repeated}}
                result = e.({{name}}).getImmediate{{singular}}(index - n{{prev_child}}) and partialAccessor = "{{singular}}(" + (index - n{{prev_child}}).toString() + ")"
            {{/is_repeated}}
            {{^is_repeated}}
                index = n{{prev_child}} and result = e.({{name}}).getImmediate{{singular}}() and partialAccessor = "{{singular}}()"
            {{/is_repeated}}
            {{/is_child}}
            {{/properties}}
      ))
      {{/has_children}}
  {{/classes}}
}
}

/**
 * Gets the "immediate" parent of `e`. "Immediate" means not taking into account node resolution: for example
 * if `e` has conversions, `getImmediateParent(e)` will give the bottom conversion in the hidden AST.
 */
Element getImmediateParent(Element e) {
    // `unique` is used here to tell the optimizer that there is in fact only one result
    // this is tested by the `library-tests/parent/no_double_parents.ql` test
    result = unique(Element x | e = Impl::getImmediateChild(x, _, _) | x)
}

/**
* Gets the immediate child indexed at `index`. Indexes are not guaranteed to be contiguous, but are guaranteed to be distinct. `accessor` is bound the the method giving the given child.
*/
Element getImmediateChildAndAccessor(Element e, int index, string accessor) {
    exists(string partialAccessor | result = Impl::getImmediateChild(e, index, partialAccessor) and accessor = "getImmediate" + partialAccessor)
}

/**
 * Gets the child indexed at `index`. Indexes are not guaranteed to be contiguous, but are guaranteed to be distinct. `accessor` is bound the the method giving the given child. Node resolution is carried out.
 */
Element getChildAndAccessor(Element e, int index, string accessor) {
    exists(string partialAccessor | result = Impl::getImmediateChild(e, index, partialAccessor).resolve() and accessor = "get" + partialAccessor)
}
