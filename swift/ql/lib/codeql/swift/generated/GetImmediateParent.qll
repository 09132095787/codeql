// generated by codegen/codegen.py
import codeql.swift.elements

// we are defining this class mainly to leverage existing generation machinery
// when we generate getters in classes we use the db predicate with `this`. In order to reuse that we need a class here
// as well
private class ElementWithChildAccessor extends Element {
  // why does this look more complicated than it should?
  // * the none()  simplifies generation, as we can append `or ...` without a special case for the first item
  // * the `exists` and the `x` variables are there to reuse the same generation done in classes (where the variables
  //   are used to hide nodes via resolution)
  Element getAnImmediateChild() {
    none()
    or
    exists(BraceStmt x | abstract_function_decl_bodies(this, x) and result = x)
    or
    exists(ParamDecl x, int index | abstract_function_decl_params(this, index, x) and result = x)
    or
    exists(AccessorDecl x, int index |
      abstract_storage_decl_accessor_decls(this, index, x) and result = x
    )
    or
    exists(Expr x | any_try_exprs(this, x) and result = x)
    or
    exists(Expr x | apply_exprs(this, x) and result = x)
    or
    exists(Argument x, int index | apply_expr_arguments(this, index, x) and result = x)
    or
    exists(Expr x | arguments(this, _, x) and result = x)
    or
    exists(Expr x, int index | array_expr_elements(this, index, x) and result = x)
    or
    exists(Expr x | assign_exprs(this, x, _) and result = x)
    or
    exists(Expr x | assign_exprs(this, _, x) and result = x)
    or
    exists(BraceStmt x | auto_closure_exprs(this, x) and result = x)
    or
    exists(Expr x | bind_optional_exprs(this, x) and result = x)
    or
    exists(Pattern x | binding_patterns(this, x) and result = x)
    or
    exists(AstNode x, int index | brace_stmt_elements(this, index, x) and result = x)
    or
    exists(PatternBindingDecl x, int index |
      capture_list_expr_binding_decls(this, index, x) and result = x
    )
    or
    exists(ClosureExpr x | capture_list_exprs(this, x) and result = x)
    or
    exists(Pattern x | case_label_items(this, x) and result = x)
    or
    exists(Expr x | case_label_item_guards(this, x) and result = x)
    or
    exists(Stmt x | case_stmts(this, x) and result = x)
    or
    exists(CaseLabelItem x, int index | case_stmt_labels(this, index, x) and result = x)
    or
    exists(BraceStmt x | closure_exprs(this, x) and result = x)
    or
    exists(Expr x | condition_element_booleans(this, x) and result = x)
    or
    exists(Pattern x | condition_element_patterns(this, x) and result = x)
    or
    exists(Expr x | condition_element_initializers(this, x) and result = x)
    or
    exists(BraceStmt x | defer_stmts(this, x) and result = x)
    or
    exists(Expr x, int index | dictionary_expr_elements(this, index, x) and result = x)
    or
    exists(Stmt x | do_catch_stmts(this, x) and result = x)
    or
    exists(CaseStmt x, int index | do_catch_stmt_catches(this, index, x) and result = x)
    or
    exists(BraceStmt x | do_stmts(this, x) and result = x)
    or
    exists(Expr x | dot_syntax_base_ignored_exprs(this, x, _) and result = x)
    or
    exists(Expr x | dot_syntax_base_ignored_exprs(this, _, x) and result = x)
    or
    exists(Expr x | dynamic_type_exprs(this, x) and result = x)
    or
    exists(EnumElementDecl x, int index | enum_case_decl_elements(this, index, x) and result = x)
    or
    exists(ParamDecl x, int index | enum_element_decl_params(this, index, x) and result = x)
    or
    exists(Pattern x | enum_element_pattern_sub_patterns(this, x) and result = x)
    or
    exists(Expr x | enum_is_case_exprs(this, x, _, _) and result = x)
    or
    exists(TypeRepr x | enum_is_case_exprs(this, _, x, _) and result = x)
    or
    exists(EnumElementDecl x | enum_is_case_exprs(this, _, _, x) and result = x)
    or
    exists(Expr x | explicit_cast_exprs(this, x) and result = x)
    or
    exists(Expr x | expr_patterns(this, x) and result = x)
    or
    exists(Pattern x | for_each_stmts(this, x, _, _) and result = x)
    or
    exists(Expr x | for_each_stmts(this, _, x, _) and result = x)
    or
    exists(Expr x | for_each_stmt_wheres(this, x) and result = x)
    or
    exists(BraceStmt x | for_each_stmts(this, _, _, x) and result = x)
    or
    exists(Expr x | force_value_exprs(this, x) and result = x)
    or
    exists(BraceStmt x | guard_stmts(this, x) and result = x)
    or
    exists(Expr x | identity_exprs(this, x) and result = x)
    or
    exists(Expr x | if_exprs(this, x, _, _) and result = x)
    or
    exists(Expr x | if_exprs(this, _, x, _) and result = x)
    or
    exists(Expr x | if_exprs(this, _, _, x) and result = x)
    or
    exists(Stmt x | if_stmts(this, x) and result = x)
    or
    exists(Stmt x | if_stmt_elses(this, x) and result = x)
    or
    exists(Expr x | implicit_conversion_exprs(this, x) and result = x)
    or
    exists(Expr x | in_out_exprs(this, x) and result = x)
    or
    exists(Expr x |
      interpolated_string_literal_expr_interpolation_count_exprs(this, x) and result = x
    )
    or
    exists(Expr x | interpolated_string_literal_expr_literal_capacity_exprs(this, x) and result = x)
    or
    exists(TapExpr x | interpolated_string_literal_expr_appending_exprs(this, x) and result = x)
    or
    exists(Expr x | key_path_application_exprs(this, x, _) and result = x)
    or
    exists(Expr x | key_path_application_exprs(this, _, x) and result = x)
    or
    exists(Expr x | key_path_expr_parsed_roots(this, x) and result = x)
    or
    exists(Expr x | key_path_expr_parsed_paths(this, x) and result = x)
    or
    exists(StmtCondition x | labeled_conditional_stmts(this, x) and result = x)
    or
    exists(Expr x | lazy_initializer_exprs(this, x) and result = x)
    or
    exists(Expr x | lookup_exprs(this, x, _) and result = x)
    or
    exists(OpaqueValueExpr x | make_temporarily_escapable_exprs(this, x, _, _) and result = x)
    or
    exists(Expr x | make_temporarily_escapable_exprs(this, _, x, _) and result = x)
    or
    exists(Expr x | make_temporarily_escapable_exprs(this, _, _, x) and result = x)
    or
    exists(Expr x | obj_c_selector_exprs(this, x, _) and result = x)
    or
    exists(Expr x | one_way_exprs(this, x) and result = x)
    or
    exists(Expr x | open_existential_exprs(this, x, _, _) and result = x)
    or
    exists(Expr x | open_existential_exprs(this, _, x, _) and result = x)
    or
    exists(OpaqueValueExpr x | open_existential_exprs(this, _, _, x) and result = x)
    or
    exists(Expr x | optional_evaluation_exprs(this, x) and result = x)
    or
    exists(Pattern x | optional_some_patterns(this, x) and result = x)
    or
    exists(Pattern x | paren_patterns(this, x) and result = x)
    or
    exists(Expr x, int index | pattern_binding_decl_inits(this, index, x) and result = x)
    or
    exists(Pattern x, int index | pattern_binding_decl_patterns(this, index, x) and result = x)
    or
    exists(Expr x | rebind_self_in_constructor_exprs(this, x, _) and result = x)
    or
    exists(VarDecl x | rebind_self_in_constructor_exprs(this, _, x) and result = x)
    or
    exists(Expr x | repeat_while_stmts(this, x, _) and result = x)
    or
    exists(Stmt x | repeat_while_stmts(this, _, x) and result = x)
    or
    exists(Expr x | return_stmt_results(this, x) and result = x)
    or
    exists(Expr x | self_apply_exprs(this, x) and result = x)
    or
    exists(ConditionElement x, int index | stmt_condition_elements(this, index, x) and result = x)
    or
    exists(ParamDecl x, int index | subscript_decl_params(this, index, x) and result = x)
    or
    exists(Argument x, int index | subscript_expr_arguments(this, index, x) and result = x)
    or
    exists(Expr x | switch_stmts(this, x) and result = x)
    or
    exists(CaseStmt x, int index | switch_stmt_cases(this, index, x) and result = x)
    or
    exists(Expr x | tap_expr_sub_exprs(this, x) and result = x)
    or
    exists(BraceStmt x | tap_exprs(this, x, _) and result = x)
    or
    exists(Expr x | throw_stmts(this, x) and result = x)
    or
    exists(BraceStmt x | top_level_code_decls(this, x) and result = x)
    or
    exists(Expr x | tuple_element_exprs(this, x, _) and result = x)
    or
    exists(Expr x, int index | tuple_expr_elements(this, index, x) and result = x)
    or
    exists(Pattern x, int index | tuple_pattern_elements(this, index, x) and result = x)
    or
    exists(TypeRepr x | type_expr_type_reprs(this, x) and result = x)
    or
    exists(Pattern x | typed_patterns(this, x) and result = x)
    or
    exists(TypeRepr x | typed_pattern_type_reprs(this, x) and result = x)
    or
    exists(Expr x | vararg_expansion_exprs(this, x) and result = x)
    or
    exists(Stmt x | while_stmts(this, x) and result = x)
    or
    exists(Expr x, int index | yield_stmt_results(this, index, x) and result = x)
  }
}

/**
 * Gets any of the "immediate" children of `e`. "Immediate" means not taking into account node resolution: for example
 * if the AST child is the first of a series of conversions that would normally be hidden away, this will select the
 * next conversion down the hidden AST tree instead of the corresponding fully uncoverted node at the bottom.
 * This predicate is mainly intended to be used to test uniqueness of parents.
 */
cached
Element getAnImmediateChild(Element e) {
  result = e.(ElementWithChildAccessor).getAnImmediateChild()
}

/**
 * Gets the "immediate" parent of `e`. "Immediate" means not taking into account node resolution: for example
 * if `e` has conversions, `getImmediateParent(e)` will give the bottom conversion in the hidden AST.
 */
Element getImmediateParent(Element e) {
  // `unique` is used here to tell the optimizer that there is in fact only one result
  // this is tested by the `library-tests/parent/no_double_parents.ql` test
  result = unique(Element x | e = getAnImmediateChild(x) | x)
}
