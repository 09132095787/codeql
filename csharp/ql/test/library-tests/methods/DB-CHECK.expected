[INVALID_KEY] predicate methods(@method id, string name, @type declaring_type_id, @type_or_ref type_id, @method unbound_id): The key set {id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 4:
Tuple 1 in row 28: (828,"M",827,1087,813)
Tuple 2 in row 29: (828,"M",827,1087,1135)
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 827: @"(294)<(366)>;type". The ID may expand to @"{@"{@"{@";namespace"}.Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"{@";namespace"}.System;namespace"}.Int32;type"}>;type"
	Relevant element: Full ID for 1087: @"(365);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"};typeRef"
	Relevant element: Full ID for 813: @"(365) (294).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@";namespace"}.Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 827: @"(294)<(366)>;type". The ID may expand to @"{@"{@"{@";namespace"}.Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"{@";namespace"}.System;namespace"}.Int32;type"}>;type"
	Relevant element: Full ID for 1087: @"(365);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"};typeRef"
	Relevant element: Full ID for 1135: @"(365) (294).M((296) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@";namespace"}.Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
[INVALID_KEY] predicate constructors(@constructor id, string name, @type declaring_type_id, @constructor unbound_id): The key set {id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 3:
Tuple 1 in row 14: (897,"Nested",830,332)
Tuple 2 in row 15: (897,"Nested",830,1143)
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 830: @"(827).Nested;type". The ID may expand to @"{@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.Nested;type"
	Relevant element: Full ID for 332: @"(297)((296) p1);constructor". The ID may expand to @"{@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.Nested;type"}({@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}_0;typeparameter"} p1);constructor"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 830: @"(827).Nested;type". The ID may expand to @"{@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.Nested;type"
	Relevant element: Full ID for 1143: @"(297)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
[INVALID_KEY_SET] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {name, parent_id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 34: (1005,"p1",1083,0,0,828,1138)
Tuple 2 in row 35: (1005,"p1",1083,0,0,828,1348)
	Relevant element: Full ID for 1005: @"(828)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1138: @"(1135)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1005: @"(828)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1348: @"(813)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
[INVALID_KEY_SET] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {name, parent_id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 42: (1031,"p1",1083,0,0,897,335)
Tuple 2 in row 43: (1031,"p1",1083,0,0,897,1146)
	Relevant element: Full ID for 1031: @"(897)_0;parameter". The ID may expand to @"{@"{@"{@"(294)<(366)>;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 335: @"(332)_0;parameter". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}.Nested;type"}({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1031: @"(897)_0;parameter". The ID may expand to @"{@"{@"{@"(294)<(366)>;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 1146: @"(1143)_0;parameter". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
[INVALID_KEY_SET] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {name, parent_id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 36: (1006,"p2",1083,1,0,828,1140)
Tuple 2 in row 37: (1006,"p2",1083,1,0,828,1350)
	Relevant element: Full ID for 1006: @"(828)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1140: @"(1135)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1006: @"(828)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1350: @"(813)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
[INVALID_KEY_SET] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {index, parent_id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 34: (1005,"p1",1083,0,0,828,1138)
Tuple 2 in row 35: (1005,"p1",1083,0,0,828,1348)
	Relevant element: Full ID for 1005: @"(828)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1138: @"(1135)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1005: @"(828)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1348: @"(813)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
[INVALID_KEY_SET] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {index, parent_id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 42: (1031,"p1",1083,0,0,897,335)
Tuple 2 in row 43: (1031,"p1",1083,0,0,897,1146)
	Relevant element: Full ID for 1031: @"(897)_0;parameter". The ID may expand to @"{@"{@"{@"(294)<(366)>;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 335: @"(332)_0;parameter". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}.Nested;type"}({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1031: @"(897)_0;parameter". The ID may expand to @"{@"{@"{@"(294)<(366)>;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 1146: @"(1143)_0;parameter". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
[INVALID_KEY_SET] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {index, parent_id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 36: (1006,"p2",1083,1,0,828,1140)
Tuple 2 in row 37: (1006,"p2",1083,1,0,828,1350)
	Relevant element: Full ID for 1006: @"(828)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1140: @"(1135)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1006: @"(828)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1350: @"(813)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
[INVALID_KEY] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 34: (1005,"p1",1083,0,0,828,1138)
Tuple 2 in row 35: (1005,"p1",1083,0,0,828,1348)
	Relevant element: Full ID for 1005: @"(828)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1138: @"(1135)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1005: @"(828)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1348: @"(813)_0;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_0;parameter"
[INVALID_KEY] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 36: (1006,"p2",1083,1,0,828,1140)
Tuple 2 in row 37: (1006,"p2",1083,1,0,828,1350)
	Relevant element: Full ID for 1006: @"(828)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1140: @"(1135)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1006: @"(828)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 828: @"(365) (827).M((366) p1,(366) p2);method". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Void;type"} {@"{@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}<{@"{@"(111).System;namespace"}.Int32;type"}>;type"}.M({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1,{@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p2);method"
	Relevant element: Full ID for 1350: @"(813)_1;parameter". The ID may expand to @"{@"{@"{@"(111).System;namespace"}.Void;type"} {@"{@"(111).Methods;namespace"}.TestCollidingMethods`1;type"}.M({@"{@"(111).System;namespace"}.Int32;type"} p1,{@"{@"(111).System;namespace"}.Int32;type"} p2);method"}_1;parameter"
[INVALID_KEY] predicate params(@parameter id, string name, @type_or_ref type_id, int index, int mode, @parameterizable parent_id, @parameter unbound_id): The key set {id} does not functionally determine all fields.
Here is a pair of tuples that agree on the key set but differ at index 6:
Tuple 1 in row 42: (1031,"p1",1083,0,0,897,335)
Tuple 2 in row 43: (1031,"p1",1083,0,0,897,1146)
	Relevant element: Full ID for 1031: @"(897)_0;parameter". The ID may expand to @"{@"{@"{@"(294)<(366)>;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 335: @"(332)_0;parameter". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}.Nested;type"}({@"{@"(130).TestCollidingMethods`1;type"}_0;typeparameter"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1031: @"(897)_0;parameter". The ID may expand to @"{@"{@"{@"(294)<(366)>;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
	Relevant element: Full ID for 1083: @"(366);typeRef". The ID may expand to @"{@"{@"{@";namespace"}.System;namespace"}.Int32;type"};typeRef"
	Relevant element: Full ID for 897: @"(830)((366) p1);constructor". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}<{@"(112).Int32;type"}>;type"}.Nested;type"}({@"{@"{@";namespace"}.System;namespace"}.Int32;type"} p1);constructor"
	Relevant element: Full ID for 1146: @"(1143)_0;parameter". The ID may expand to @"{@"{@"{@"(130).TestCollidingMethods`1;type"}.Nested;type"}({@"{@"(111).System;namespace"}.Int32;type"} p1);constructor"}_0;parameter"
