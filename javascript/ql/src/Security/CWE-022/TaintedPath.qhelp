<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">
<qhelp>

<overview>
<p>
Accessing files using paths constructed from user-controlled data can allow an attacker to access
unexpected resources. This can result in sensitive information being revealed or deleted, or an
attacker being able to influence behavior by modifying unexpected files.
</p>
</overview>

<recommendation>
<p>
Validate user input before using it to construct a file path.
</p>

<p>
The choice of validation depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.
</p>

<p>
In the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder.
First, normalize the path using <code>path.resolve</code> or <code>fs.realpathSync</code> to remove any ".." segments.
Then check that the normalized path starts with the root folder.
Note that the normalization step is important, since otherwise even a path that starts with the root folder could be used to access files outside the root folder.
</p>

<p>
In the latter case, you can use a library like the <code>sanitize-filename</code> npm package to eliminate any special characters from the file path.
Note that it is <i>not</i> sufficient to only remove "../" sequences: for example, applying this filter to ".../...//" would still result in the string "../".
</p>

<p>
Finally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.
</p>
</recommendation>

<example>
<p>
In the first example, a file name is read from an HTTP request and then used to access a file within a root folder.
However, a malicious user could enter a file name containing "../" segments to navigate outside the root folder and access sensitive files.
</p>

<sample src="examples/TaintedPath.js" />

<p>
The second example shows how to fix this.
First, the file name is resolved relative to a root folder, which has the side effect of normalizing the path and removing any "../" segments.
Then, <code>fs.realpathSync</code> is used to resolve any symbolic links in the path.
Finally, we check that the normalized path starts with the root folder's path, which ensures that the file is contained within the root folder.
</p>

<sample src="examples/TaintedPathGood.js" />

</example>

<references>
<li>OWASP: <a href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal</a>.</li>
<li>npm: <a href="https://www.npmjs.com/package/sanitize-filename">sanitize-filename</a> package.</li>
</references>
</qhelp>
